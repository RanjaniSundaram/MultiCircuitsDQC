import sys

sys.path.append("..")

from commons.qChannel import qChannel
from commons.qGraph import qGraph
from commons.qNode import qNode
from commons.tools import get_classical_time
from routing_algorithms.dp_shortest_path import dp_shortest_path
from typing import List
from commons.tree_node import tree_node
from collections import deque


class hop_shortest_path:
    """
        This class finds all shortest paths (between any pair) in q quantum network (qGraph) in terms of least number
        of hops (BFS). A balanced tree will be generated by default over the path.
    """

    def __init__(self, g: qGraph, decoherence_time: float):
        self._decoherence_time = decoherence_time
        self._g = g
        self._node_map = {v.id: idx for idx, v in enumerate(g.V)}
        # a hash map to convert nodes' id to indices; in case node ids are random

        self._adj_lst = hop_shortest_path._adj_list(g, self._node_map)

    def get_shortest_path(self, src: qNode, dst: qNode, NON_THROTTLING: bool = False):
        """
        :param src: source qNode
        :param dst: destination qNode
        :return: shortest path(tree) between src and dst
        """
        if src.id not in self._node_map or dst.id not in self._node_map:
            return None
        src_idx, dst_idx = self._node_map[src.id], self._node_map[dst.id]
        shortest_path = hop_shortest_path._bfs(adj_lst=self._adj_lst, src=src_idx, dst=dst_idx)
        if src_idx == dst_idx or len(shortest_path) == 0:
            return None
        shortest_tree = hop_shortest_path._path_to_balanced_tree(self._g, id_map=self._node_map, path=shortest_path,
                                                                 lo=0, hi=len(shortest_path) - 1)
        _, _, shortest_tree = dp_shortest_path.update_ent_time_tree(shortest_tree, shortest_tree.avr_ent_time,
                                                                    NON_THROTTLING)

        return shortest_tree if shortest_tree.one_round_ent_time < self._decoherence_time else None

    def get_shortest_path_without_update(self, src: qNode, dst: qNode):
        return self.get_shortest_path(src, dst)

    @staticmethod
    def _adj_list(g: qGraph, id_map: dict) -> List[List[int]]:
        adj_lst = [[] for _ in range(len(g.V))]
        for e in g.E:
            if e.this.memory > 0 and e.other.memory > 0 and e.residual_capacity > 0:
                # both sides should have enough memory to create an edge
                adj_lst[id_map[e.this.id]].append(id_map[e.other.id])
                adj_lst[id_map[e.other.id]].append(id_map[e.this.id])
        return adj_lst

    @staticmethod
    def _bfs(adj_lst: List[List[int]], src: int, dst: int):
        def _helper(parent: List[int], current_node: int):
            if parent[current_node] == -1:
                # reached to src
                return [current_node]
            path = _helper(parent, parent[current_node])
            path.append(current_node)
            return path
        seen = [False] * len(adj_lst)
        parent = [-1] * len(adj_lst)
        bag = deque([src])  # a queue for hold current unseen nodes
        seen[src] = True
        dst_found = False
        while len(bag) > 0:
            cur = bag.pop()
            for n_nod in adj_lst[cur]:
                if not seen[n_nod]:
                    parent[n_nod] = cur
                    bag.appendleft(n_nod)
                    seen[n_nod] = True
                if n_nod == dst:
                    # reached to destination
                    dst_found = True
                    break
            if dst_found:
                break
        return [] if parent[dst] == -1 else _helper(parent, dst)

    @staticmethod
    def _path_to_balanced_tree(g: qGraph, id_map: dict, path: List[int], lo: int, hi: int) -> tree_node:
        if hi <= lo:
            # should not happen
            return tree_node()
        if hi - lo == 1:
            # reached to link layer
            this_id, other_id = id_map[path[lo]], id_map[path[hi]]
            e = g.get_edge(this_id, other_id)
            return tree_node(data=qChannel(this=g.get_node(id_map[path[lo]]),
                                           other=g.get_node(id_map[path[hi]]), channels_num=e.channels_num,
                                           optical_bsm_rate=e.optical_bsm_rate, optical_bsm_time=e.optical_bsm_time),
                             avr_ent_time=e.avr_ent_time, one_round_ent_time=e.avr_success_time)
        root_pos = (lo + hi) // 2
        root_id = id_map[path[root_pos]]
        root_node = g.get_node(root_id)
        lo_to_root_classical = get_classical_time(root_node.loc.distance(g.get_node(id_map[lo]).loc))
        root_to_hi_classical = get_classical_time(root_node.loc.distance(g.get_node(id_map[hi]).loc))
        left_tree = hop_shortest_path._path_to_balanced_tree(g, id_map, path, lo=lo, hi=root_pos)
        right_tree = hop_shortest_path._path_to_balanced_tree(g, id_map, path, lo=root_pos, hi=hi)
        return tree_node(data=root_node, left=left_tree, right=right_tree,
                         avr_ent_time=(1.5 * max(left_tree.avr_ent_time, right_tree.avr_ent_time) +
                                       max(lo_to_root_classical, root_to_hi_classical) +  # time to send BSM res back
                                       root_node.bsm_time) / root_node.bsm_success_rate,
                         left_avr_ent_time=left_tree.avr_ent_time, right_avr_ent_time=right_tree.avr_ent_time)